# 1.进程有多少种状态？

创建,就绪,执行,阻塞,终止
 *  创建: 一个进程启动就进入创建状态,需要获取系统资源创建进程管理块(PCB)完成资源创建
 *  就绪: 在创建状态完成之后, 进程已经准备好,处于就绪状态,但是未获得处理器资源,无法运行
 *  运行: 获取处理器资源,被系统调度,当具有时间片开始进入运行状态.如果进程的时间片用完了就进入就绪状态
 *  阻塞: 在运行状态期间,如果进行阻塞操作,此时进程暂时无法操作进入阻塞态,完成后进入就绪状态,等待再次获取处理器资源终
 *  止状态: 进程结束或是被操作系统终止.

# 2.线程之间的通信方式

信号,互斥锁,读写锁,自旋锁,条件变量,信号量

1. 信号: Linux中使用pthread_kill()函数对线程发信号
2. 互斥锁,读写锁,自旋锁.    
   		互斥锁确保同一时间只有一个线程访问共享资源,当锁被占用时试图对其加锁的线程都会进入阻塞状态
      		读写锁确保同一时间可以有多个线程读取,但是同一时间只能有一个线程写入.
      		自旋锁上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对 CPU 的霸占会导致 CPU 资源的浪费。
      			 所以自旋锁适用于并行结构（多个处理器）或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。 
      		互斥锁：共享资源只允许一个进程进行访问，进程没有请求到锁后，会继续进行其它事，当锁被释放后，再来申请 自旋锁：进程没有请求到锁后，会原地等待，知道锁被释放
3. 条件变量: 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。
4. 信号量: 信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

# 3.进程通信的方式

管道,命名管道,信号,消息队列,共享内存,内存映射,信号量,Socket
 	1. 管道（匿名管道）：本质上是内核中维护的一块内存缓冲区，Linux系统中由pipe()函数创建，只能用于具有亲缘关系的进程间通信。
	2. 命名管道：不同于匿名管道之处在于它提供了一个路径名与之关联，进程通过访问该路径就能相互通信，适用于没有亲缘关系的进程间通信。
	3. 信号：一种异步通信方式，信号可以让一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
	4. 消息队列：是一个消息链表且随内核持续，具有特定的格式和特定的优先级，由具有写权限的进程添加消息，由具有读权限的进程读走消息。
	5. 共享内存：允许两个或者多个进程共享物理内存的同一块区域（通常被称为段），无需内核介入，速度比管道快。
	6. 内存映射 ：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
	7. 信号量：主要用来解决进程和线程间并发执行时的同步问题，信号量操作分为P操作和V操作，P将信号量值-1，V将信号量值+1。当信号量值<=0时，进行P操作进线程会被阻塞，		直到另一个进程或线程执行了V操作将信号量的值大于0时。
	8. Socket 套接字：一般用于网络中不同主机上的进程之间的通信，且提供了应用层进程利用网络协议交换数据的机制。

# 4.进程和线程的区别?

地址空间,开销,并发性,内存

1. 地址空间:进程有独立的地址空间, 线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间

2. 开销: 进程的上下文切换时间开销远大于线程的上下切换时间
3. 进程的并发性较低,线程的并发性高
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，依赖应用程序。
5. 进程有独立的内存空间，除CPU外，系统不会为线程分配内存
6. 一个进程崩溃后， 在保护模式下不会对其他进程产生影响，但是一个线程崩溃了，整个进程都死掉。

# 5.线程和协成的区别？

1. 线程是操作系统的资源，线程的创建、切换、终止都会造成资源的浪费，而协程是靠编译语言来实现的，所以协程也被称作用户态线程
2. 线程是并行的，协程是并发的。
3. 线程同步，协程异步
4. 线程抢占式，协程非抢占式，需要手动切换 

# 6.死锁是怎么产生的？

1. 死锁：两个或两个以上得进程在争夺共享资源时产生的一种互相等待的现象。

2. 死锁的条件：

   1. 互斥条件，进程对资源的使用是独占形式了，同一时间只有一个进程能够使用该资源，其他进程的请求会等待。

   2. 请求和保护条件，当一个进程未使用完一个资源，又请求另一个资源，而那个资源正在被另一个进程使用，该请求进程阻塞，在这期间，请求进程不会释放已有资源。
   3. 不剥夺条件，一个进程未使用完的资源，无法被剥夺，只有等进程完成后自己释放该资源。
   4.  环路条件，多个进程互相等待，形成一个环路。死锁的原因：资源竞争。

3. 死锁的解决方法：有序资源分配法，银行家算法 

# 7.虚拟内存与物理内存

1. 直接使用物理内存的缺陷：隔离性差，物理内存不够用； 

2. 虚拟内存；每个进程都可以自己搞一份，在需要的时候映射到物理内存，变相扩大了物理内存；同时隔离性也比较好；

# 8.条件变量

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

* 个线程等待"条件变量的条件成立"而挂起；
* 另一个线程使"条件成立"（给出条件成立信号）。

# 9.TCP与UDP

1. TCP是面向对象连接；而UDP是无面向对象连接 

2. TCP确保所传输的数据一定会到达目的地，但时间却不能保证；而UDP不确保数据会按原来顺序到达，但具有实时性 

3. TCP的使用场景是不在意传输数据速度，但在意传输数据准确；而UDP的使用场景则是对实时性要求较高 

4. TCP的首部开销大，占用20字节；而UDP的首部开销小，只占用8个字节
5. TCP只支持点对点的数据传输；而UDP支持一对一、一对多、多对多等各种场景
6. TCP有拥塞控制和流量控制来确保数据的安全性，但如果网络拥塞的话，速度会比较慢；UDP即使在网络拥塞的时候，传输速度也不会慢



# 10.OSI七层模型

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

* 应用层，管理应用进程间的通信规则。

* 表示层，对数据进行处理。

* 会话层，用来管理进程。

* 传输层，提供数据的传输服务。

* 网络层，进行逻辑地址的查询。

* 数据链路层，建立节点的连接和信息校验。

* 物理层，负责最底层的数据传输。  

# 11.TCP如何实现可靠传输

1. 首先可靠传输是指没差错、不丢失、不重复、按序到达。

2. 相应的TCP头部有检验和来保证不出差错，然后会采用重传和确认机制来保障不重复，不丢失，按序，还会有流量控制和拥塞控制来减少丢包率。

# 12.滑动窗口

滑动窗口机制主要是通过窗口大小实现流量控制，进而解决发送方发送数据过快、过多导致的接收端缓存区数据溢出导致的丢包现象；回退n步协议、停等式协议、选择重传协议





# 13. static关键字的作用

关键字、作用域、生命周期、共享数据 

1. 限制数据的作用域（隐藏） 所有没有加 static 的全局变量和函数都具有全局可见性，其它源文件中也可以访问。被 static 修饰的全局变量和函数只能在**当前源文件中访问**，其它源文件访问不了，利用这个特性可以在不同的文件中定义同名变量和同名函数，而不必担心命名冲突。
2. 延长数据的生命周期 ,加`static`的局部变量 的 静态变量存储在**静态区**，直到程序运行结束才会释放。
3. 静态成员被该类所有对象共享,不管创建多少个该类的对象，所有对象都**共享这一块内存**。静态成员**本质上属于类**，可以**通过类名直接访问**。
4. 静态成员函数中不能访问普通的成员变量，**只能访问静态成员变量**，并且在静态成员函数中**没有 this 指针**。



# 14.野指针怎么产生和避免

概念: 野指针是指指向的位置是随机的、不可知的、不正确的。(一般是没有初始化)

产生原因:

	1. 指针变量未初始化或随便赋值: 指针变量没有初始化, 其值随机, 如果对其解引用, 结果未知
	1. 指针释放后未置空: 有时候指针在释放后没有赋值为`nullptr`, 虽然指针变量指向的内存被释放到了,但是指针变量中的值还在, 这时指针变量就是指向一个未知的内存, 如果解引用, 结果未知
	1. 指针操作超出了变量的作用域: 函数中变量了局部变量的地址或者引用, 因为局部变量除了作用域就被释放了,这时候返回的地址指向的内存也是未知的.

避免:

	1. 指针变量一定要初始化, 可以初始化为`nullptr`, 对`nullptr`操作不会有问题
	1. 释放后置为`nullptr`



# 15. C语言与C++的区别?

面向对象,面向过程, 重载, void, struct, 函数参数默认值, 内联函数, 引用, 动态内存分配, 作用域

1. C语言面向过程, C++支持面向对象, 所有C语言没有面向对象的封装, 继承, 多态等特性
2. C++支持函数重载, C语言不支持;
3. C语言`struct`中不能有函数, 而C++语言`struct`中可以有函数;
4. C语言函数参数不支持默认值, 而C++语言支持参数默认值;
5. C++语言迟滞内联函数, 而C语言不支持;
6. C++支持引用, C语言不支持
7. C语言采用`malloc`和`free`函数动态申请和释放内存, 而C++使用`new`和`delete`运算符
8. C语言只有局部和全局两个作用域, 而C++中有局部, 全局, 类, 名称空间作用域



# 16. const和define的区别

作用、编译阶段、预处理阶段、简单替换、类型检查、内存,

const 在 C 语言中表示只读，编译器禁止对它修饰的变量进行修改，在 C++ 中增加了常量的语义。而 define 用于定义宏，而宏也可以用于定义常量。

1. const 生效于编译阶段，而 define 生效于预处理阶段； 

2. define只是简单的字符串替换，没有类型检查，而 const 有对应的数据类型，编译器要进行判断的，可以避免一些低级的错误； 
3. 用 define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的；
4. define 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const  在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝； 
5. 可以对 const 常量进行调试，但是不能对宏常量进行调试。 



# 17.extern相关

extern的作用: 声明外部变量和函数、静态存储区（全局区）

1. `extern` 可以置于变量声明或者函数声明前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它文件中寻找其定义。
2. extern 变量表示声明一个变量，表示该变量是一个外部变量，也就是全局变量，所以 extern 修饰的变量保存在静态存储区（全局区），全局变量如果没有显示初始化，会默认初始化为 0
3. . extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。

# 18.const的用法

 变量、指针、函数参数、成员、成员方法

1. 用在变量身上，表示该变量只读，不能对它的值进行修改 

2. 结合指针一起使用 

   * const int * p; 

   * 常量指针 int * const p; 

   * 指针常量 const int * const p; 

   *  const int * p 是常量指针，表示指针变量 p 所指向的内容不能修改，指针变量 p 的内容可以修改； 

   * int * const p 是指针常量，表示指针变量 p 的内容不能修改，指针变量 p 所指向的内容可以修改； 

   * const int * const p 表示指针变量 p 的内容和所指向的内容都不可以修改。  

     

3. const 用于函数参数 void foo(const int * p); void foo(const int & p);    const 用于形参时说明形参在函数内部不能被改变，这是非常有用的，有时候函数参数传递指针或者引用，在函数内部不希望对指针和引用指向的数据进行修改，可以加上 const。
4. 在类中修饰成员方法，防止在方法中修改非 static 成员
5. const修饰的全局变量会变为仅仅该文件可见。如果想在其他文件直接使用需要在其他文件进行extern声明一下。
6. const 修饰类的成员变量，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。   

