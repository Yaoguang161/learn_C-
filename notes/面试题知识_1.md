# 1. 1.进程有多少种状态？

创建,就绪,执行,阻塞,终止
 *  创建: 一个进程启动就进入创建状态,需要获取系统资源创建进程管理块(PCB)完成资源创建
 *  就绪: 在创建状态完成之后, 进程已经准备好,处于就绪状态,但是未获得处理器资源,无法运行
 *  运行: 获取处理器资源,被系统调度,当具有时间片开始进入运行状态.如果进程的时间片用完了就进入就绪状态
 *  阻塞: 在运行状态期间,如果进行阻塞操作,此时进程暂时无法操作进入阻塞态,完成后进入就绪状态,等待再次获取处理器资源终
 *  止状态: 进程结束或是被操作系统终止.

# 2. 2.线程之间的通信方式

信号,互斥锁,读写锁,自旋锁,条件变量,信号量

1. 信号: Linux中使用pthread_kill()函数对线程发信号
2. 互斥锁,读写锁,自旋锁.    
   		互斥锁确保同一时间只有一个线程访问共享资源,当锁被占用时试图对其加锁的线程都会进入阻塞状态
      		读写锁确保同一时间可以有多个线程读取,但是同一时间只能有一个线程写入.
      		自旋锁上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对 CPU 的霸占会导致 CPU 资源的浪费。
      			 所以自旋锁适用于并行结构（多个处理器）或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。 
      		互斥锁：共享资源只允许一个进程进行访问，进程没有请求到锁后，会继续进行其它事，当锁被释放后，再来申请 自旋锁：进程没有请求到锁后，会原地等待，知道锁被释放
3. 条件变量: 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。
4. 信号量: 信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

# 3. 3.进程通信的方式

管道,命名管道,信号,消息队列,共享内存,内存映射,信号量,Socket
 	1. 管道（匿名管道）：本质上是内核中维护的一块内存缓冲区，Linux系统中由pipe()函数创建，只能用于具有亲缘关系的进程间通信。
	2. 命名管道：不同于匿名管道之处在于它提供了一个路径名与之关联，进程通过访问该路径就能相互通信，适用于没有亲缘关系的进程间通信。
	3. 信号：一种异步通信方式，信号可以让一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
	4. 消息队列：是一个消息链表且随内核持续，具有特定的格式和特定的优先级，由具有写权限的进程添加消息，由具有读权限的进程读走消息。
	5. 共享内存：允许两个或者多个进程共享物理内存的同一块区域（通常被称为段），无需内核介入，速度比管道快。
	6. 内存映射 ：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
	7. 信号量：主要用来解决进程和线程间并发执行时的同步问题，信号量操作分为P操作和V操作，P将信号量值-1，V将信号量值+1。当信号量值<=0时，进行P操作进线程会被阻塞，		直到另一个进程或线程执行了V操作将信号量的值大于0时。
	8. Socket 套接字：一般用于网络中不同主机上的进程之间的通信，且提供了应用层进程利用网络协议交换数据的机制。

# 4. 4.进程和线程的区别?

地址空间,开销,并发性,内存

1. 地址空间:进程有独立的地址空间, 线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间

2. 开销: 进程的上下文切换时间开销远大于线程的上下切换时间
3. 进程的并发性较低,线程的并发性高
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，依赖应用程序。
5. 进程有独立的内存空间，除CPU外，系统不会为线程分配内存
6. 一个进程崩溃后， 在保护模式下不会对其他进程产生影响，但是一个线程崩溃了，整个进程都死掉。

# 5. 5.线程和协成的区别？

1. 线程是操作系统的资源，线程的创建、切换、终止都会造成资源的浪费，而协程是靠编译语言来实现的，所以协程也被称作用户态线程
2. 线程是并行的，协程是并发的。
3. 线程同步，协程异步
4. 线程抢占式，协程非抢占式，需要手动切换 

# 6. 6.死锁是怎么产生的？

1. 死锁：两个或两个以上得进程在争夺共享资源时产生的一种互相等待的现象。

2. 死锁的条件：

   1. 互斥条件，进程对资源的使用是独占形式了，同一时间只有一个进程能够使用该资源，其他进程的请求会等待。

   2. 请求和保护条件，当一个进程未使用完一个资源，又请求另一个资源，而那个资源正在被另一个进程使用，该请求进程阻塞，在这期间，请求进程不会释放已有资源。
   3. 不剥夺条件，一个进程未使用完的资源，无法被剥夺，只有等进程完成后自己释放该资源。
   4.  环路条件，多个进程互相等待，形成一个环路。死锁的原因：资源竞争。

3. 死锁的解决方法：有序资源分配法，银行家算法 

# 7. 7.虚拟内存与物理内存

1. 直接使用物理内存的缺陷：隔离性差，物理内存不够用； 

2. 虚拟内存；每个进程都可以自己搞一份，在需要的时候映射到物理内存，变相扩大了物理内存；同时隔离性也比较好；

# 8. 8.条件变量

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

* 个线程等待"条件变量的条件成立"而挂起；
* 另一个线程使"条件成立"（给出条件成立信号）。

# 9. 9.TCP与UDP

1. TCP是面向对象连接；而UDP是无面向对象连接 

2. TCP确保所传输的数据一定会到达目的地，但时间却不能保证；而UDP不确保数据会按原来顺序到达，但具有实时性 

3. TCP的使用场景是不在意传输数据速度，但在意传输数据准确；而UDP的使用场景则是对实时性要求较高 

4. TCP的首部开销大，占用20字节；而UDP的首部开销小，只占用8个字节
5. TCP只支持点对点的数据传输；而UDP支持一对一、一对多、多对多等各种场景
6. TCP有拥塞控制和流量控制来确保数据的安全性，但如果网络拥塞的话，速度会比较慢；UDP即使在网络拥塞的时候，传输速度也不会慢



# 10. 10.OSI七层模型

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

* 应用层，管理应用进程间的通信规则。

* 表示层，对数据进行处理。

* 会话层，用来管理进程。

* 传输层，提供数据的传输服务。

* 网络层，进行逻辑地址的查询。

* 数据链路层，建立节点的连接和信息校验。

* 物理层，负责最底层的数据传输。  

# 10. 11.TCP如何实现可靠传输

1. 首先可靠传输是指没差错、不丢失、不重复、按序到达。

2. 相应的TCP头部有检验和来保证不出差错，然后会采用重传和确认机制来保障不重复，不丢失，按序，还会有流量控制和拥塞控制来减少丢包率。

# 10. 12.滑动窗口

滑动窗口机制主要是通过窗口大小实现流量控制，进而解决发送方发送数据过快、过多导致的接收端缓存区数据溢出导致的丢包现象；回退n步协议、停等式协议、选择重传协议





# 10. 13. static关键字的作用

关键字、作用域、生命周期、共享数据 

1. 限制数据的作用域（隐藏） 所有没有加 static 的全局变量和函数都具有全局可见性，其它源文件中也可以访问。被 static 修饰的全局变量和函数只能在**当前源文件中访问**，其它源文件访问不了，利用这个特性可以在不同的文件中定义同名变量和同名函数，而不必担心命名冲突。
2. 延长数据的生命周期 ,加`static`的局部变量 的 静态变量存储在**静态区**，直到程序运行结束才会释放。
3. 静态成员被该类所有对象共享,不管创建多少个该类的对象，所有对象都**共享这一块内存**。静态成员**本质上属于类**，可以**通过类名直接访问**。
4. 静态成员函数中不能访问普通的成员变量，**只能访问静态成员变量**，并且在静态成员函数中**没有 this 指针**。



# 10. 14.野指针怎么产生和避免

概念: 野指针是指指向的位置是随机的、不可知的、不正确的。(一般是没有初始化)

产生原因:

	1. 指针变量未初始化或随便赋值: 指针变量没有初始化, 其值随机, 如果对其解引用, 结果未知
	1. 指针释放后未置空: 有时候指针在释放后没有赋值为`nullptr`, 虽然指针变量指向的内存被释放到了,但是指针变量中的值还在, 这时指针变量就是指向一个未知的内存, 如果解引用, 结果未知
	1. 指针操作超出了变量的作用域: 函数中变量了局部变量的地址或者引用, 因为局部变量除了作用域就被释放了,这时候返回的地址指向的内存也是未知的.

避免:

	1. 指针变量一定要初始化, 可以初始化为`nullptr`, 对`nullptr`操作不会有问题
	1. 释放后置为`nullptr`



# 10. 15. C语言与C++的区别?

面向对象,面向过程, 重载, void, struct, 函数参数默认值, 内联函数, 引用, 动态内存分配, 作用域

1. C语言面向过程, C++支持面向对象, 所有C语言没有面向对象的封装, 继承, 多态等特性
2. C++支持函数重载, C语言不支持;
3. C语言`struct`中不能有函数, 而C++语言`struct`中可以有函数;
4. C语言函数参数不支持默认值, 而C++语言支持参数默认值;
5. C++语言迟滞内联函数, 而C语言不支持;
6. C++支持引用, C语言不支持
7. C语言采用`malloc`和`free`函数动态申请和释放内存, 而C++使用`new`和`delete`运算符
8. C语言只有局部和全局两个作用域, 而C++中有局部, 全局, 类, 名称空间作用域



# 10. 16. const和define的区别

作用、编译阶段、预处理阶段、简单替换、类型检查、内存,

const 在 C 语言中表示只读，编译器禁止对它修饰的变量进行修改，在 C++ 中增加了常量的语义。而 define 用于定义宏，而宏也可以用于定义常量。

1. const 生效于编译阶段，而 define 生效于预处理阶段； 

2. define只是简单的字符串替换，没有类型检查，而 const 有对应的数据类型，编译器要进行判断的，可以避免一些低级的错误； 
3. 用 define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的；
4. define 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const  在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝； 
5. 可以对 const 常量进行调试，但是不能对宏常量进行调试。 



# 10. 17.extern相关

extern的作用: 声明外部变量和函数、静态存储区（全局区）

1. `extern` 可以置于变量声明或者函数声明前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它文件中寻找其定义。
2. extern 变量表示声明一个变量，表示该变量是一个外部变量，也就是全局变量，所以 extern 修饰的变量保存在静态存储区（全局区），全局变量如果没有显示初始化，会默认初始化为 0
3. . extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。

# 10. 18.const的用法

 变量、指针、函数参数、成员、成员方法

1. 用在变量身上，表示该变量只读，不能对它的值进行修改 

2. 结合指针一起使用 

   * const int * p; 

   * 常量指针 int * const p; 

   * 指针常量 const int * const p; 

   *  const int * p 是常量指针，表示指针变量 p 所指向的内容不能修改，指针变量 p 的内容可以修改； 

   * int * const p 是指针常量，表示指针变量 p 的内容不能修改，指针变量 p 所指向的内容可以修改； 

   * const int * const p 表示指针变量 p 的内容和所指向的内容都不可以修改。  

     

3. const 用于函数参数 void foo(const int * p); void foo(const int & p);    const 用于形参时说明形参在函数内部不能被改变，这是非常有用的，有时候函数参数传递指针或者引用，在函数内部不希望对指针和引用指向的数据进行修改，可以加上 const。
4. 在类中修饰成员方法，防止在方法中修改非 static 成员
5. const修饰的全局变量会变为仅仅该文件可见。如果想在其他文件直接使用需要在其他文件进行extern声明一下。
6. const 修饰类的成员变量，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。   



#  19. C 语言里面 volatile，可以和 const 同时使用

volatile 的含义是防止编译器对该代码进行优化，这个值可能变掉的。

而 const 的含义是在代码中不能对该变量进行修改。



# 10. 20.引用的概念

概念: 引用可以看做是数据的一个别名

注意: 

* 引用必须引用合法的内存空间 

- 引用在定义时必须初始化 
- 引用一旦初始化后，就不能再引用其它数据 
- 引用在定义时需要加上 &，在使用时不能加 &，使用时加 & 表示取地址 
- 函数中不要返回局部变量的引用 
- 引用的本质是指针，低层的实现还是指针。



# 10. 21.指针和引用的区别



区别:	

1. 指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。
2. 引用不可以为空, 当被创建时必须初始化, 而指针变量可以是空值, 在任何时候都可以初始化
3. 指针有多级, 引用只能有一级
4. 引用使用时无需解引用, 而指针需要解引用
5. 指针变量的值可以是NULL, 但是引用的值不可以为NULL
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了
7. `sizeof `引用得到的是所指向的变量（对象）的大小，而 `sizeof `指针得到的是指针变量本身的大小
8. 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本
9. 指针和引用进行++运算意义不一样。



# 10. 22.内联函数和函数的区别，内联函数的作用

函数调用开销、寻址、展开代码、提高效率、宏定义 , inline

区别:

1. 内联函数与普通函数的区别:
   1. 内联函数函数避免了函数调用的开销; 普通函数有调用的开销;
   2. 普通函数调用时需要寻址, 内联函数不需要寻址
   3. 内联函数体要求代码简单,不能复杂, 不然会被编译器优化成普通函数执行
2. 内联函数的作用:
   1. 编译器预处理,在调用内联函数的地方将内联函数的语句复制到调用函数的地方,直接展开代码执行,提高效率.,
   2. 同时解决宏定义的问题.

# 10. 23.C++的内存管理

C++ 的内存分区主要有：

* 代码区

* 未初始化数据区（BSS）

* 已初始化数据区（DATA）

* 栈区（Stack）

* 堆区（Heap）

实际中;

​	栈区

​	空闲区域

​	堆区

​	数据区(已初始化	未初始化)

​	代码区

# 10. 24.栈和堆的区别

管理方式、空间大小、是否产生内存碎片、生长方向、分配方式、分配效率 

1. 管理方式 对于栈来讲，是由编译器自动管理，无需手动控制；对于堆来说，分配和释放都是由程序员控制的

2. 空间大小 总体来说，栈的空间是要小于堆的。堆内存几乎是没有什么限制的；但是对于栈来讲，一般是有一定的空间大小的。

3. 碎片问题 对于堆来讲，由于分配和释放是由程序员控制的（利用new/delete 或 malloc/free），频繁的操作势必会造成内存空间的不连续，从而造成大量的内存碎片，使程序效率降低。

4. 对于栈来讲，则不会存在这个问题，因为栈是先进后出的数据结构，在某一数据弹出之前，它之前的所有数据都已经弹出。
5. 生长方向 对于堆来讲，生长方向是向上的，也就是沿着内存地址增加的方向，对于栈来讲，它的生长方式是向下的，也就是沿着内存地址减小的方向增长。
6. 分配方式 堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器实现的，无需我们手工实现。
7. 分配效率 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率很高。
8. 堆的效率要比栈底的多。

# 10. 25.什么是内存泄露，如何检测

概念、避免内存泄露、检测

1. 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

2. 避免内存泄露的方法主要就是要有良好的编码习惯，动态开辟内存空间，及时释放内存。也可以采用智能指针来避免内存泄露。
3. 可以采用静态分析技术、源代码插装技术等进行检测。

# 10. 26.内存对齐  

什么是内存对齐、内存对齐的原因、内存对齐的规则  

1. 什么是内存对齐 现代计算机中内存空间都是按照 字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数 k（通常它为4或8）的倍数，这就是所谓的内存对齐。
2. 内存对齐的原因 - 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的。某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
3. 内存对齐的规则 - 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数
