# 27. STL容器优势与劣势总结

1. Vector（向量）：
   - 优势：
     - 支持快速的随机访问，即可以通过索引直接访问元素。
     - 在尾部插入和删除元素的操作效率高。
     - 内存是连续分配的，因此可以更高效地利用缓存。
   - 劣势：
     - 在插入和删除元素时，需要移动其他元素，因此效率较低。
     - 在中间位置插入或删除元素的成本较高。
2. List（链表）：
   - 优势：
     - 在任意位置插入和删除元素的效率高，不需要移动其他元素。
     - 不需要连续的内存分配，可以动态增长。
   - 劣势：
     - 不支持随机访问，只能通过迭代器进行顺序访问。
     - 访问元素的效率较低，因为需要遍历链表。
3. Deque（双端队列）：
   - 优势：
     - 支持快速的随机访问，可以通过索引直接访问元素。
     - 在首尾插入和删除元素的操作效率高。
     - 内存是分块连续分配的，可以更高效地利用缓存。
   - 劣势：
     - 在中间位置插入和删除元素的成本较高。
4. Queue（队列）：
   - 优势：
     - 支持先进先出（FIFO）的操作，适用于需要按顺序处理元素的场景。
     - 可以快速在队尾插入元素，并在队头删除元素。
   - 劣势：
     - 不支持随机访问和中间位置的插入/删除操作。

# 28. STL面试题提问总结

1. 什么是STL？它包含哪些组件？
   - STL是C++标准模板库的缩写，是一组泛型的软件组件，提供了常用的数据结构和算法。
   - 它包含容器（如vector、list、map）、算法（如排序、搜索）和迭代器（用于遍历容器）三个主要组件。
2. vector和list之间有什么区别？你会在什么情况下选择其中之一？
   - vector是一个动态数组，元素在内存中连续存储，支持快速的随机访问，但插入和删除元素的效率较低。
   - list是一个双向链表，元素在内存中非连续存储，支持快速的插入和删除操作，但访问元素的效率较低。
   - 选择vector当需要频繁访问元素、在尾部插入和删除元素，并且不需要在中间位置插入和删除元素的情况下。
   - 选择list当需要频繁在任意位置插入和删除元素，并且不需要快速随机访问元素的情况下。
3. 什么是迭代器？它们的作用是什么？
   - 迭代器是STL中用于遍历容器的抽象概念，类似于指针的功能。
   - 它们提供了一种统一的方式来访问容器中的元素，无论容器是数组、链表还是其他类型。
   - 迭代器可以进行自增、自减等操作，并且可以通过解引用操作来获取所指向元素的值。
4. 什么是算法？STL中提供了哪些常用的算法？
   - 算法是STL中用于处理容器元素的函数模板，如排序、查找、复制等操作。
   - STL提供了大量的算法，包括排序算法（如sort、stable_sort）、查找算法（如find、binary_search）、变动算法（如copy、fill）等。
5. 什么是关联容器？STL提供了哪些关联容器？
   - 关联容器是一类基于键值对的容器，提供了快速的查找和插入操作。
   - STL提供了两种主要的关联容器：map和set。
   - map是一种有序的关联容器，存储键值对，并根据键自动排序。每个键都是唯一的。
   - set是一种有序的关联容器，存储唯一的元素，并根据元素值自动排序。

6. vector和deque之间有什么区别？你会在什么情况下选择其中之一？

   - vector和deque都是动态数组，支持随机访问。

   - vector的元素在内存中连续存储，适用于在尾部进行频繁的插入和删除操作，并且需要随机访问元素的场景。

   - deque的元素以块状存储，适用于在首尾进行频繁的插入和删除操作，并且需要随机访问元素的场景。

7. 什么是迭代器的分类？它们之间有什么区别？

   - 迭代器分为输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。

   - 输入迭代器和输出迭代器分别用于读取和写入数据。

   - 前向迭代器可以向前遍历容器，双向迭代器可以进行双向遍历。

   - 随机访问迭代器支持随机访问、算术操作和指针运算，具有最强大的功能。

8. 什么是逆向迭代器？在哪些容器中可以使用逆向迭代器？

   - 逆向迭代器是一种特殊的迭代器，用于逆序遍历容器的元素。

   - 逆向迭代器通过操作符"--"进行递减操作，使得迭代方向与正向迭代器相反。

   - 可以在支持双向遍历的容器（如list、deque）中使用逆向迭代器。

9. STL中的容器和算法之间有何关系？

   - 容器提供了数据的存储和管理，算法提供了对容器中数据的处理和操作。

   - 算法是独立于容器的，可以应用于不同类型的容器，通过迭代器进行操作。

   - STL提供了一致的接口和规范，使得不同的容器可以方便地使用相同的算法进行处理。

10. STL中的排序算法有哪些？它们的特点和使用场景是什么？

    - STL提供了多种排序算法，包括sort、stable_sort、partial_sort等。

    - sort是一种快速排序算法，具有较快的速度和较好的平均性能。

    - stable_sort是一种稳定的排序算法，保持相等元素的相对顺序。

    - partial_sort是一种部分排序算法，可以部分排序容器中的元素，使得部分区域按照特定顺序排列。

11. STL中的map和unordered_map有什么区别？你会在什么情况下选择其中之一？

    - map是基于红黑树实现的有序关联容器，元素按照键自动排序。
    - unordered_map是基于哈希表实现的无序关联容器，元素无特定顺序。
    - 选择map当需要有序的键值对存储和快速查找操作，并且对元素的顺序有要求时。
    - 选择unordered_map当不需要特定顺序，只关心快速的插入和查找操作时。

12. STL中的算法和自定义类型如何配合使用？

    - STL的算法是通用的，可以使用于各种自定义类型，只需满足对应算法的要求。
    - 需要提供自定义类型的迭代器，使算法能够访问自定义类型的元素。
    - 可以通过重载操作符或提供自定义比较函数，以便算法正确比较和操作自定义类型的对象。

13. 什么是STL的分配器（allocator）？它的作用是什么？你了解哪些与分配器相关的内容？

    - 分配器是STL中用于管理内存分配和释放的组件，负责为容器分配和回收内存。
    - 它的作用是在需要动态分配内存的操作中，为容器提供合适的内存块，以避免频繁的系统调用。
    - 与分配器相关的内容包括空间配置器（allocator）、构造器（construct）、析构器（destroy）和空间释放器（deallocator）。

14. STL中的算法复杂度和稳定性有什么要求？你能给出一些具体的例子吗？

    - STL中的算法要求在时间和空间复杂度上具有一定的性能保证。
    - 时间复杂度上，算法通常要求在最坏情况下具有较好的性能，如排序算法的平均时间复杂度为O(n log n)。
    - 空间复杂度上，算法要求不会占用过多的额外内存空间，如排序算法中的原地排序算法。
    - 稳定性指算法在排序或其他操作中能够保持相等元素的相对顺序不变。
    - 例如，stable_sort算法是稳定的，而sort算法不保证稳定性。

15. 你了解STL中的迭代器失效问题吗？在什么情况下会发生迭代器失效？

    - 迭代器失效指迭代器在容器发生改变后不能继续使用或引发未定义行为。
    - 迭代器失效的情况包括：在容器中插入或删除元素，导致原有迭代器失效；对容器进行重新分配，使得迭代器无效；在循环中使用end()迭代器作为循环条件，容器发生改变后导致迭代器失效。
    - 在迭代器失效的情况下，需要小心处理迭代器的使用，避免出现错误。



# 29. Linux网络编程面试提问总结

1. 什么是套接字（Socket）？

    答案：套接字是一种用于在网络中进行通信的编程接口，它提供了一种机制，使得应用程序能够通过网络发送和接收数据。套接字是网络编程中的重要概念，它是网络通信的端点。

2. 请解释一下TCP和UDP协议的区别。 

   答案：TCP（传输控制协议）是一种面向连接的协议，它提供可靠的、有序的数据传输，适用于对数据可靠性要求较高的应用。UDP（用户数据报协议）是一种无连接的协议，它提供不可靠的、无序的数据传输，适用于对实时性要求较高的应用。

3. 在C++中，如何使用套接字进行网络编程？ 

   答案：在C++中，可以使用Socket API（套接字应用程序接口）来进行网络编程。通常使用`socket()`函数创建套接字，然后使用`bind()`函数将套接字绑定到特定的地址和端口，接着使用`listen()`函数监听连接请求，最后使用`accept()`函数接受连接请求并创建新的套接字用于通信。

4. 如何在C++中使用TCP套接字进行客户端和服务器之间的通信？ 

   答案：对于TCP客户端，可以使用`socket()`函数创建套接字，然后使用`connect()`函数连接到服务器。连接成功后，可以使用`send()`和`recv()`函数发送和接收数据。对于TCP服务器，可以使用`socket()`函数创建套接字，然后使用`bind()`函数绑定到服务器地址和端口，接着使用`listen()`函数监听连接请求。当有连接请求到达时，可以使用`accept()`函数接受连接并创建新的套接字用于通信。

5. 如何在C++中使用UDP套接字进行客户端和服务器之间的通信？ 

   答案：对于UDP客户端，可以使用`socket()`函数创建套接字，然后使用`sendto()`函数发送数据到服务器。对于UDP服务器，可以使用`socket()`函数创建套接字，然后使用`bind()`函数绑定到服务器地址和端口，接着使用`recvfrom()`函数接收来自客户端的数据。

6. 请解释什么是IP地址和端口号。 答案：IP地址是用于在网络中标识主机的唯一地址。它由32位（IPv4）或128位（IPv6）的数字表示。端口号是在一个主机上运行的进程的标识符，它是一个16位的数字，范围从0到65535。在网络通信中，通过将IP地址和端口号结合起来，可以唯一地标识网络中的特定进程。

7. 在Linux中，如何使用Socket API进行多线程编程？ 答案：在Linux中，可以使用多线程编程来实现并发的网络通信。可以使用线程库（如`pthread`）创建和管理线程。每个线程可以拥有自己的套接字，用于与客户端进行通信。需要注意线程之间的同步和互斥，以避免竞态条件和数据不一致的问题。

8. 在网络编程中，什么是阻塞和非阻塞套接字？ 答案：阻塞和非阻塞是描述套接字的工作模式的术语。在阻塞模式下，当进行读取或写入操作时，套接字函数会一直等待直到操作完成才返回。在非阻塞模式下，当进行读取或写入操作时，套接字函数会立即返回，无论操作是否完成。非阻塞套接字通常需要使用轮询或事件驱动的方式来检查操作的完成情况。

9. 如何处理TCP粘包问题？ 答案：TCP粘包问题指的是发送方发送的多个小数据包在接收方接收时可能会合并成一个大数据包的情况。可以使用以下方法来处理TCP粘包问题：

   - 使用固定长度的消息：在发送数据时，将数据按照固定的长度进行分割，并在接收方按照相同长度进行拼接。
   - 使用特定的分隔符：在发送数据时，在每个数据包的末尾添加特定的分隔符，接收方根据分隔符进行数据的拆分。
   - 使用消息头部记录数据长度：在发送数据时，将数据长度作为消息的头部信息发送，接收方先读取头部信息，然后根据长度读取对应数量的数据。

10. 如何实现一个基于TCP的简单聊天室？ 答案：要实现一个基于TCP的简单聊天室，可以使用一个服务器和多个客户端。服务器接收客户端的连接，并将客户端的消息广播给其他客户端。实现的关键点包括：服务器监听和接受连接、多线程处理客户端的消息、消息的广播和同步等。

11. 在Linux网络编程中，如何处理并发连接？ 

    答案：有几种方法可以处理并发连接：

    - 使用多进程：可以使用`fork()`函数创建子进程来处理每个连接。每个子进程都有自己的套接字，可以独立地处理连接。但是多进程模型消耗系统资源较高。
    - 使用多线程：可以使用线程库（如pthread）创建多个线程来处理连接。每个线程都有自己的套接字，可以并发地处理连接。需要注意线程之间的同步和互斥。
    - 使用非阻塞IO和事件驱动：使用非阻塞套接字，通过轮询或事件驱动的方式来检查套接字是否有数据可读或可写。可以使用系统调用（如`select()`、`poll()`、`epoll()`）来实现事件驱动的并发处理。

12. 如何设置套接字的超时时间？ 答案：可以使用`setsockopt()`函数设置套接字选项来设置超时时间。对于连接超时，可以使用`SO_SNDTIMEO`选项设置发送超时时间，使用`SO_RCVTIMEO`选项设置接收超时时间。这样在发送或接收数据时，如果超过设定的超时时间，将会返回超时错误。

13. 在Linux中，如何获取客户端的IP地址和端口号？ 答案：在服务器端，可以使用`getpeername()`函数获取客户端的IP地址和端口号。该函数需要传入已连接的套接字以及指向存储结果的`sockaddr`结构体指针。`sockaddr`结构体中的`sin_addr`成员存储客户端的IP地址，`sin_port`成员存储客户端的端口号。

14. 如何实现一个基于UDP的简单文件传输程序？ 答案：要实现基于UDP的简单文件传输程序，可以使用客户端将文件分割成小块，并通过UDP发送给服务器端。服务器端接收到数据块后，重新组装文件。需要实现的关键点包括：客户端将文件分割成数据块、数据块的序号和校验和、客户端发送数据块、服务器端接收数据块并重组文件。

15. 如何进行网络调试和故障排除？ 

    答案：在网络调试和故障排除时，可以采用以下方法：

    - 使用网络抓包工具（如Wireshark）分析数据包的传输情况，检查是否有错误、丢包等问题。
    - 使用`ping`命令检查网络连通性。
    - 使用`netstat`命令查看网络连接状态。
    - 使用日志记录和调试输出来跟踪程序的执行过程，排查可能的错误。
    - 针对特定的问题，可以使用网络诊断工具（如`traceroute`）来定位问题所在的网络节点。

16. 在Linux中，如何实现Socket的复用？ 答案：在Linux中，可以通过设置套接字选项来实现Socket的复用。可以使用`setsockopt()`函数，将`SO_REUSEADDR`选项设置为1，以允许地址的重用。这样可以在套接字关闭后立即重新绑定相同的地址和端口。

17. 在TCP通信中，什么是三次握手和四次挥手？ 答案：三次握手是建立TCP连接的过程，它包括以下步骤：

    * 客户端发送一个带有SYN标志的连接请求数据包给服务器端。

    * 服务器端收到请求后，回复一个带有SYN/ACK标志的确认数据包给客户端。

    * 客户端收到服务器端的确认后，发送一个带有ACK标志的确认数据包给服务器端。这样，TCP连接就建立起来了。

18. 四次挥手是关闭TCP连接的过程，它包括哪些步骤？

    1. 客户端发送一个带有FIN标志的关闭连接请求给服务器端。
    2. 服务器端收到请求后，发送一个带有ACK标志的确认数据包给客户端，进入半关闭状态。
    3. 服务器端发送一个带有FIN标志的关闭连接请求给客户端。
    4. 客户端收到请求后，发送一个带有ACK标志的确认数据包给服务器端，完成关闭连接。
    5. 如何设置非阻塞套接字？ 答案：可以通过将套接字设置为非阻塞模式来实现非阻塞操作。可以使用`fcntl()`函数，将套接字的文件描述符设置为非阻塞模式。可以使用`F_SETFL`命令和`O_NONBLOCK`标志来设置非阻塞模式。

19. 在Linux中，如何使用`select()`函数实现多路复用？ 答案：`select()`函数是一种多路复用的机制，可以在单个线程中同时监视多个套接字的状态。它接收三个描述符集参数，用于读取、写入和异常情况的监视。可以使用`FD_ZERO()`、`FD_SET()`和`FD_ISSET()`函数来设置和检查描述符集。`select()`函数将阻塞，直到至少一个描述符准备好或超时发生。

20. 在Linux中，如何使用`epoll()`函数进行高效的事件驱动编程？ 答案：`epoll()`函数是一种高效的事件驱动编程机制，可以用于处理大量的并发连接。它使用一个事件表（epoll file descriptor）来存储和管理被监视的套接字。可以使用`epoll_create()`函数创建事件表，然后使用`epoll_ctl()`函数向事件表中添加或删除套接字。使用`epoll_wait()`函数可以等待就绪的套接字事件并返回就绪的套接字列表。使用`epoll()`函数可以实现高效的事件驱动模型，避免了轮询和阻塞等效率低下的方式。

21. 在Linux中，如何使用`SO_REUSEPORT`选项实现端口复用？ 答案：`SO_REUSEPORT`选项可以实现多个套接字绑定到同一个IP地址和端口上，从而实现端口复用。可以使用`setsockopt()`函数，将`SO_REUSEPORT`选项设置为1，以允许端口复用。在多个套接字绑定到同一个IP地址和端口后，操作系统会在收到数据时将数据分发给所有绑定到该端口的套接字。

22. 如何实现一个简单的HTTP服务器？ 答案：要实现一个简单的HTTP服务器，可以使用套接字和HTTP协议进行通信。关键步骤包括：

    - 创建套接字并绑定到服务器地址和端口。

    - 使用`listen()`函数监听连接请求。

    - 使用循环接受连接请求，对于每个连接请求，使用`accept()`函数创建新的套接字用于通信。

    - 接收HTTP请求消息，解析请求报文，提取请求的路径和方法等信息。

    - 根据请求的路径和方法，生成相应的HTTP响应消息。

    - 使用`send()`函数将HTTP响应消息发送给客户端。

    - 关闭连接套接字，继续循环等待下一个连接请求。

23. 在Linux中，如何使用`getaddrinfo()`函数进行地址解析？ 答案：`getaddrinfo()`函数用于将主机名和服务名解析为网络地址结构。可以使用该函数获取与指定主机名和服务名对应的地址列表。使用`getaddrinfo()`函数的一般步骤包括：

    - 创建一个`addrinfo`结构体，并设置相关参数。

    - 调用`getaddrinfo()`函数，将主机名和服务名作为参数传入，同时传入上一步创建的`addrinfo`结构体。

    - `getaddrinfo()`函数会返回一个地址列表，包含解析得到的网络地址。

    - 遍历地址列表，可以获取每个地址的IP地址和端口号等信息。

    - 使用完毕后，调用`freeaddrinfo()`函数释放地址列表的内存空间。

24. 在Linux中，如何使用`poll()`函数进行I/O多路复用？ 答案：`poll()`函数是一种I/O多路复用机制，用于监视多个文件描述符的状态。可以创建一个`pollfd`结构体数组，每个结构体描述一个文件描述符及其感兴趣的事件。然后使用`poll()`函数来等待就绪的文件描述符。`poll()`函数将阻塞，直到有文件描述符准备就绪或超时发生。使用`revents`字段可以获取文件描述符的就绪事件。

# 30.局部变量初始化写法

1. 尽量使用`auto`

```c++
#include <iostream>
#include <cstring>
#include <cstdint>

using namespace std;
int main(int argc, char **argv)
{
    auto i = [&]{
        for(int i = 0; i < argc; i ++)
        {
            if(!strcmp(argv[i],"-h"))
            return i;
        }
        return -1;
    }();
    cout << i << endl;
    return 0;
}
```

2. 不使用`C c`这种方式, 这个属于没有初始化.

```c++
#include <iostream>
#include <type_traits>
#include <cstring>
#include <cstdint>
#include <memory>

using namespace std;
struct C{
    int a;
    int b;
};
int main(int argc, char **argv)
{
    //放入栈中
	C c;   		  //错误写法, 没有初始化
    C c{};        //正确写法, 但是不推荐,能正确提示未初始化.
    auto c = C{}; //推荐写法
    cout << c.a << endl;
    
    //在需要new的情况下
    auto c = new C;    //还是有可能不初始化	
    auto c = std::make_unique<C>(); //推荐写法,等于帮你调用C();
    auto c = std::make_unique<C>(1,2) //gcc已经支持,等于C{1,2}
    cout << c->a << endl;
    
     return 0;
}
```



总结写法:

```c++
int i1;   //错误,不要前置类型
auto i2 = int(); //正确

auto p1 = new C;     //错误
auto p2 = make_unique<C>();  //正确

auto i = size_t(0);			//解决方案
auto c = char(0);          //解决方案
auto s = std::string("hello"); //避免隐式类型转换
auto s = "hello"s;     // C++14新增  operator""s,与上面同理, 所在命名空间using namespace std::literals;
```



3. vector写法

```c++
#include <iostream>
#include <type_traits>
#include <cstring>
#include <cstdint>
#include <memory>
using namespace std;

int main(int argc, char **argv)
{
	auto a = std::vector<char>(0x1ff);
    for(auto i = size_t(0); i < a.size(); i ++)  //推荐写法,避免隐式类型转换
    {
        cerr << a[i];
    }
    std::max(1, a.size());  //错误, 会被提醒,两边数据类型不相等.
    std::max(size_t(1), a.size()); //正确, 避免隐式类型转换,改为显式类型转换
     return 0;
}
```



















































