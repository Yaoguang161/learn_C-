# 27. STL容器优势与劣势总结

1. Vector（向量）：
   - 优势：
     - 支持快速的随机访问，即可以通过索引直接访问元素。
     - 在尾部插入和删除元素的操作效率高。
     - 内存是连续分配的，因此可以更高效地利用缓存。
   - 劣势：
     - 在插入和删除元素时，需要移动其他元素，因此效率较低。
     - 在中间位置插入或删除元素的成本较高。
2. List（链表）：
   - 优势：
     - 在任意位置插入和删除元素的效率高，不需要移动其他元素。
     - 不需要连续的内存分配，可以动态增长。
   - 劣势：
     - 不支持随机访问，只能通过迭代器进行顺序访问。
     - 访问元素的效率较低，因为需要遍历链表。
3. Deque（双端队列）：
   - 优势：
     - 支持快速的随机访问，可以通过索引直接访问元素。
     - 在首尾插入和删除元素的操作效率高。
     - 内存是分块连续分配的，可以更高效地利用缓存。
   - 劣势：
     - 在中间位置插入和删除元素的成本较高。
4. Queue（队列）：
   - 优势：
     - 支持先进先出（FIFO）的操作，适用于需要按顺序处理元素的场景。
     - 可以快速在队尾插入元素，并在队头删除元素。
   - 劣势：
     - 不支持随机访问和中间位置的插入/删除操作。

# 28. STL面试题提问总结

1. 什么是STL？它包含哪些组件？
   - STL是C++标准模板库的缩写，是一组泛型的软件组件，提供了常用的数据结构和算法。
   - 它包含容器（如vector、list、map）、算法（如排序、搜索）和迭代器（用于遍历容器）三个主要组件。
2. vector和list之间有什么区别？你会在什么情况下选择其中之一？
   - vector是一个动态数组，元素在内存中连续存储，支持快速的随机访问，但插入和删除元素的效率较低。
   - list是一个双向链表，元素在内存中非连续存储，支持快速的插入和删除操作，但访问元素的效率较低。
   - 选择vector当需要频繁访问元素、在尾部插入和删除元素，并且不需要在中间位置插入和删除元素的情况下。
   - 选择list当需要频繁在任意位置插入和删除元素，并且不需要快速随机访问元素的情况下。
3. 什么是迭代器？它们的作用是什么？
   - 迭代器是STL中用于遍历容器的抽象概念，类似于指针的功能。
   - 它们提供了一种统一的方式来访问容器中的元素，无论容器是数组、链表还是其他类型。
   - 迭代器可以进行自增、自减等操作，并且可以通过解引用操作来获取所指向元素的值。
4. 什么是算法？STL中提供了哪些常用的算法？
   - 算法是STL中用于处理容器元素的函数模板，如排序、查找、复制等操作。
   - STL提供了大量的算法，包括排序算法（如sort、stable_sort）、查找算法（如find、binary_search）、变动算法（如copy、fill）等。
5. 什么是关联容器？STL提供了哪些关联容器？
   - 关联容器是一类基于键值对的容器，提供了快速的查找和插入操作。
   - STL提供了两种主要的关联容器：map和set。
   - map是一种有序的关联容器，存储键值对，并根据键自动排序。每个键都是唯一的。
   - set是一种有序的关联容器，存储唯一的元素，并根据元素值自动排序。

6. vector和deque之间有什么区别？你会在什么情况下选择其中之一？

   - vector和deque都是动态数组，支持随机访问。

   - vector的元素在内存中连续存储，适用于在尾部进行频繁的插入和删除操作，并且需要随机访问元素的场景。

   - deque的元素以块状存储，适用于在首尾进行频繁的插入和删除操作，并且需要随机访问元素的场景。

7. 什么是迭代器的分类？它们之间有什么区别？

   - 迭代器分为输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。

   - 输入迭代器和输出迭代器分别用于读取和写入数据。

   - 前向迭代器可以向前遍历容器，双向迭代器可以进行双向遍历。

   - 随机访问迭代器支持随机访问、算术操作和指针运算，具有最强大的功能。

8. 什么是逆向迭代器？在哪些容器中可以使用逆向迭代器？

   - 逆向迭代器是一种特殊的迭代器，用于逆序遍历容器的元素。

   - 逆向迭代器通过操作符"--"进行递减操作，使得迭代方向与正向迭代器相反。

   - 可以在支持双向遍历的容器（如list、deque）中使用逆向迭代器。

9. STL中的容器和算法之间有何关系？

   - 容器提供了数据的存储和管理，算法提供了对容器中数据的处理和操作。

   - 算法是独立于容器的，可以应用于不同类型的容器，通过迭代器进行操作。

   - STL提供了一致的接口和规范，使得不同的容器可以方便地使用相同的算法进行处理。

10. STL中的排序算法有哪些？它们的特点和使用场景是什么？

    - STL提供了多种排序算法，包括sort、stable_sort、partial_sort等。

    - sort是一种快速排序算法，具有较快的速度和较好的平均性能。

    - stable_sort是一种稳定的排序算法，保持相等元素的相对顺序。

    - partial_sort是一种部分排序算法，可以部分排序容器中的元素，使得部分区域按照特定顺序排列。

11. STL中的map和unordered_map有什么区别？你会在什么情况下选择其中之一？

    - map是基于红黑树实现的有序关联容器，元素按照键自动排序。
    - unordered_map是基于哈希表实现的无序关联容器，元素无特定顺序。
    - 选择map当需要有序的键值对存储和快速查找操作，并且对元素的顺序有要求时。
    - 选择unordered_map当不需要特定顺序，只关心快速的插入和查找操作时。

12. STL中的算法和自定义类型如何配合使用？

    - STL的算法是通用的，可以使用于各种自定义类型，只需满足对应算法的要求。
    - 需要提供自定义类型的迭代器，使算法能够访问自定义类型的元素。
    - 可以通过重载操作符或提供自定义比较函数，以便算法正确比较和操作自定义类型的对象。

13. 什么是STL的分配器（allocator）？它的作用是什么？你了解哪些与分配器相关的内容？

    - 分配器是STL中用于管理内存分配和释放的组件，负责为容器分配和回收内存。
    - 它的作用是在需要动态分配内存的操作中，为容器提供合适的内存块，以避免频繁的系统调用。
    - 与分配器相关的内容包括空间配置器（allocator）、构造器（construct）、析构器（destroy）和空间释放器（deallocator）。

14. STL中的算法复杂度和稳定性有什么要求？你能给出一些具体的例子吗？

    - STL中的算法要求在时间和空间复杂度上具有一定的性能保证。
    - 时间复杂度上，算法通常要求在最坏情况下具有较好的性能，如排序算法的平均时间复杂度为O(n log n)。
    - 空间复杂度上，算法要求不会占用过多的额外内存空间，如排序算法中的原地排序算法。
    - 稳定性指算法在排序或其他操作中能够保持相等元素的相对顺序不变。
    - 例如，stable_sort算法是稳定的，而sort算法不保证稳定性。

15. 你了解STL中的迭代器失效问题吗？在什么情况下会发生迭代器失效？

    - 迭代器失效指迭代器在容器发生改变后不能继续使用或引发未定义行为。
    - 迭代器失效的情况包括：在容器中插入或删除元素，导致原有迭代器失效；对容器进行重新分配，使得迭代器无效；在循环中使用end()迭代器作为循环条件，容器发生改变后导致迭代器失效。
    - 在迭代器失效的情况下，需要小心处理迭代器的使用，避免出现错误。

# 29. C++11面试提问总结

### 1. 什么是C++11？列举一些C++11引入的主要特性。

C++11是C++的第一个正式标准化版本，于2011年发布。它引入了许多新特性，包括：

- 自动类型推导（`auto`关键字）
- 范围`-based for`循环
- 列表初始化
- 强制转换函数（`explicit`关键字）
- 右值引用（&&操作符）
- `lambda`表达式
- 智能指针（`shared_ptr`、`unique_ptr`等）
- 并发编程支持（`std::thread`、`std::mutex`等）

### 2. C++11中的auto关键字有什么作用？请举例说明。

auto关键字用于自动推导变量的类型，根据初始化表达式的类型确定变量的类型。它可以简化代码并提高可读性。例如：

```C++
auto x = 10; // x的类型将被推导为
int auto str = "Hello"; // str的类型将被推导为const char*
```



### 3. 请解释什么是右值引用（rvalue reference）和移动语义（move semantics）。

右值引用是C++11引入的新类型引用，用于标识临时对象（右值）的引用。右值引用允许我们对右值进行特殊操作，如移动语义。移动语义是一种优化技术，可以避免在对象复制时进行昂贵的资源拷贝操作，而是将资源从一个对象“移动”到另一个对象。移动语义通常通过移动构造函数和移动赋值运算符来实现。

### 4. 列举一些C++11引入的智能指针，并简要描述它们的作用。

C++11引入了三种主要的智能指针：

- **shared_ptr**：允许多个指针共享同一个对象，并在最后一个引用被销毁时自动释放内存。
- **unique_ptr**：独占指针，提供了高效的所有权管理，确保只有一个指针可以访问对象。
- **weak_ptr**：弱引用指针，用于解决`shared_ptr`可能导致的循环引用问题。它不会增加对象的引用计数，只用于观察对象的生命周期。

### 5. 请解释什么是lambda表达式，并给一个简单的示例。

lambda表达式是C++11引入的一种匿名函数语法，它允许我们在需要函数对象的地方编写内联函数。它可以捕获外部变量，并使用简洁的语法定义函数体。示例：

```C++
// declaring_lambda_expressions1.cpp
// compile with: /EHsc /W4
#include <functional>
#include <iostream>

int main()
{

    using namespace std;

    // Assign the lambda expression that adds two numbers to an auto variable.
    auto f1 = [](int x, int y) { return x + y; };

    cout << f1(2, 3) << endl;

    // Assign the same lambda expression to a function object.
    function<int(int, int)> f2 = [](int x, int y) { return x + y; };

    cout << f2(3, 4) << endl;
}

//输出
// 5
// 7
```



### 6. C++11中的nullptr关键字有什么作用？它与NULL有何区别？

`nullptr`是C++11引入的关键字，用于表示空指针。它解决了C++中使用NULL指针可能导致的一些问题。与NULL相比，`nullptr`具有以下优势：

- 类型安全：`nullptr`的类型是`std::nullptr_t`，可以明确区分出空指针。
- 避免重载冲突：在某些情况下，`NULL`可能与整数类型发生重载冲突，而`nullptr`不会出现这种问题。
- 更好的重载匹配：`nullptr`能够更好地与函数重载进行匹配，使得函数调用更准确。